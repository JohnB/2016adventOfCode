<!-- vim: syntax=markdown -->

# Day 17

```elixir
# Note: when making the next template, something like this works well:
#   `cat day04.livemd | sed 's/02/04/' > day04.livemd`
# When inspecting lists of numbers, use "charlists: :as_lists"
#
Mix.install([
  # Join the string so a copy of dayN to dayM doesn't destroy it.
  {:kino, "~> 0.1" <> "4.2"}
])

# Join the string so a copy of dayN to dayM doesn't destroy it.
IEx.Helpers.c("/Users/johnb/dev/2" <> "0" <> "2" <> "4adventOfCode/advent_of_code.ex")
alias AdventOfCode, as: AOC
alias Kino.Input
```

## Installation and Data

```elixir
input_example = Kino.Input.textarea("Example Data", monospace: true)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_puzzleInput = Kino.Input.textarea("Puzzle Input", monospace: true)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_source_select =
  Kino.Input.select("Source", [{:example, "example"}, {:puzzle_input, "puzzle input"}])
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
data = fn ->
  (Kino.Input.read(input_source_select) == :example &&
     Kino.Input.read(input_example)) ||
    Kino.Input.read(input_puzzleInput)
end
```

## Solution

```elixir
defmodule Day17 do
  @parser ~r/(.+) -> (.+)/
  @open_doors ~w(b c d e f)
  # This is a compressed format that is expanded to a map of maps
  @dirs  %{
    "S" => %{"D" => "4", "R" => "1"},
    "1" => %{"D" => "5", "L" => "S", "R" => "2"},
    "2" => %{"D" => "6", "L" => "1", "R" => "3"},
    "3" => %{"D" => "7", "L" => "2"},
    "4" => %{"D" => "8", "R" => "5", "U" => "S"},
    "5" => %{"D" => "9", "L" => "4", "R" => "6", "U" => "1"},
    "6" => %{"D" => "A", "L" => "5", "R" => "7", "U" => "2"},
    "7" => %{"D" => "B", "L" => "6", "U" => "3"},
    "8" => %{"D" => "C", "R" => "9", "U" => "4"},
    "9" => %{"D" => "D", "L" => "8", "R" => "A", "U" => "5"},
    "A" => %{"D" => "E", "L" => "9", "R" => "B", "U" => "6"},
    "B" => %{"D" => "V", "L" => "A", "U" => "7"},
    "C" => %{"R" => "D", "U" => "8"},
    "D" => %{"L" => "C", "R" => "E", "U" => "9"},
    "E" => %{"L" => "D", "R" => "V", "U" => "A"},
    "V" => %{}
  }

  def find_path(_passcode, end_cell, end_cell, current_path) do
    [current_path]
  end

  def find_path(passcode, start_cell, end_cell, current_path) do
    # IO.inspect([passcode, start_cell, end_cell, current_path])
    [up, down, left, right | _rest] = :crypto.hash(:md5, passcode <> current_path) 
      |> Base.encode16([case: :lower])
      |> String.split("", trim: true)

    %{"U" => up, "D" => down, "L" => left, "R" => right}
      # |> AOC.inspect(label: "dirs to try")
      |> Enum.filter(fn {direction, char} -> 
        (char in @open_doors) && !is_nil(@dirs[start_cell][direction])
      end)
      # |> AOC.inspect(label: "valid dirs")
      |> Enum.map(fn {direction, _char} -> 
        paths = [find_path(passcode, @dirs[start_cell][direction], 
            end_cell, current_path <> direction)
          ]
          |> List.flatten()
        if paths == [] do
          []
        else
          # Part1: the minimum path
          Enum.min_by(paths, &String.length/1)
          
          # Part2: the maximal path
          # Enum.max_by(paths, &String.length/1)
        end
      end)
  end
  
  def solve1(text) do
    [_,  passcode, expected] = Regex.run(@parser, text)
    [path] = find_path(passcode, "S", "V", "")
    IO.puts("Path length: #{String.length(path)}")
    IO.puts("Expectation:   #{expected}")
    path
  end
end

# Examples:
#   ihgpwlah -> DDRRRD
#   kglvqrro -> DDUDRLRRUDRD
#   ulqzkmiv -> DRURDRUDDLLDLUURRDULRLDUUDDDRR
# Part1: 
#.  gdjjyniy -> DUDDRLRRRD
data.()
|> Day17.solve1()
|> IO.inspect(label: "\n*** solution")
# Part1: DUDDRLRRRD
# Part2: 578

```
