<!-- vim: syntax=markdown -->

# Day 13

```elixir
# Note: when making the next template, something like this works well:
#   `cat day04.livemd | sed 's/02/04/' > day04.livemd`
# When inspecting lists of numbers, use "charlists: :as_lists"
#
Mix.install([
  # Join the string so a copy of dayN to dayM doesn't destroy it.
  {:kino, "~> 0.1" <> "4.2"}
])

# Join the string so a copy of dayN to dayM doesn't destroy it.
IEx.Helpers.c("/Users/johnb/dev/2" <> "0" <> "1" <> "6adventOfCode/advent_of_code.ex")
alias AdventOfCode, as: AOC
alias Kino.Input
```

## Installation and Data

```elixir
input_example = Kino.Input.textarea("Example Data", monospace: true)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_puzzleInput = Kino.Input.textarea("Puzzle Input", monospace: true)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_source_select =
  Kino.Input.select("Source", [{:example, "example"}, {:puzzle_input, "puzzle input"}])
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
data = fn ->
  (Kino.Input.read(input_source_select) == :example &&
     Kino.Input.read(input_example)) ||
    Kino.Input.read(input_puzzleInput)
end
```

## Solution

```elixir

defmodule Dijkstra do
  @moduledoc """
  Implement https://en.wikipedia.org/wiki/Dijkstra's_algorithm#Algorithm
  """
  @open "."
  @infinity 1_000_000_000_000  
  @cost 1

  @doc """
  Simplistic implimentation that assumes an AOC grid structure, dots as open
  squares, same cost for all 4-way neighbors
  
  Return the set of shortest-path cell IDs from start to finish.
  """
  def shortest_path(grid, latest_nodes, node_map, cost_function, finish) do
    {updated_node_map, neighbor_nodes} = latest_nodes
    |> Enum.reduce({node_map, MapSet.new()}, fn node, {map, set} ->
      unvisited_neighbors = grid
        |> AOC.neighbors4(node)
        |> Enum.filter(fn neighbor -> 
          neighbor in Map.keys(node_map)  && node_map[neighbor].cost == @infinity
        end)

      unvisited_neighbors
      |> Enum.reduce({map, set}, fn neighbor, {map1, set1} ->
        {cost_function.(map1, node, neighbor), MapSet.put(set1, neighbor)}
      end)
    end)
    # |> AOC.inspect(label: "{updated_node_map, neighbor_nodes}")
    
    if updated_node_map[finish].path == [] do
      shortest_path(grid, MapSet.to_list(neighbor_nodes), updated_node_map, cost_function, finish)
    else
      updated_node_map
    end
  end
  
  def shortest_path(grid, start, finish) do
    # Step 1: Find the unvisited set.
    node_map = Enum.filter(AOC.grid_cells(grid), fn k -> grid[k] == @open end)
      # Step 2: Assign distances to unvisited nodes. The start node will get a 0 distance.
      |> Enum.reduce(%{}, fn index, acc ->
        if index == start do
          Map.put(acc, index, %{cost: 0, path: [start]})
        else
          # Note: an empty path list means it is un-visited
          Map.put(acc, index, %{cost: @infinity, path: []})
        end
      end)
      # |> AOC.inspect(label: "node_map")

    cost_function = fn map, a, b -> 
      # This handles Step 3 and Step 4: update path and distance from neighbors.
      cost_from_a = map[a].cost + @cost
      if map[b].cost < cost_from_a do
        # Nothing to do - the node already has the lower cost & path
        map
      else
        Map.put(map, b, %{cost: cost_from_a, path: map[a].path ++ [b]})
      end
    end
    updated_node_map = shortest_path(grid, [start], node_map, cost_function, finish)    
  end
end

defmodule Day13 do
  @open "."
  @wall "#"

  def build_office(favorite_number, grid_size) do
    grid = AOC.as_solid_grid(grid_size, grid_size, "?")
    
    AOC.grid_cells(grid)
    |> Enum.reduce(grid, fn cell_id, acc ->
      x = AOC.grid_x(acc, cell_id)
      y = AOC.grid_y(acc, cell_id)
      n = x*x + 3*x + 2*x*y + y + y*y + favorite_number
      bit_count = Integer.to_string(n, 2)
        |> String.replace("0", "")
        |> String.length()
      Map.put(acc, cell_id, rem(bit_count, 2) == 1 && @wall || @open)
    end)
  end

  def solve1(text) do
    [favorite_number, grid_size, finish_x, finish_y] = text
      |> String.split(",", trim: true)
      |> Enum.map(&String.to_integer/1)

    grid = build_office(favorite_number, grid_size)
    AOC.display_grid(grid)
    
    start = AOC.cell_id(grid, 1, 1)
    finish = AOC.cell_id(grid, finish_x, finish_y)
    AOC.inspect([start, finish], label: "Finding path")
    updated_node_map = Dijkstra.shortest_path(grid, start, finish)
    %{path: finish_path, cost: _finish_cost} = updated_node_map[finish]
    
    # Subtract the start node from the count
    IO.inspect(Enum.count(finish_path) - 1, label: "\n*** Part 1 solution (example: 11)")

    # Which nodes cost less than 50?
    updated_node_map
    |> Enum.reduce(0, fn {_node_id, %{cost: cost}}, acc ->
      if cost <= 50 do
        acc + 1
      else
        acc
      end
    end)
    |> IO.inspect(label: "\n*** Part 2 solution (example: 20)")
  end

  # def solve2(text) do
  # end
end

# Example:

data.()
|> Day13.solve1()
# Part 1: 90
# Part 2: 135

```
