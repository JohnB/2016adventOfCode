<!-- vim: syntax=markdown -->

# Day 13

```elixir
# Note: when making the next template, something like this works well:
#   `cat day04.livemd | sed 's/02/04/' > day04.livemd`
# When inspecting lists of numbers, use "charlists: :as_lists"
#
Mix.install([
  # Join the string so a copy of dayN to dayM doesn't destroy it.
  {:kino, "~> 0.1" <> "4.2"}
])

# Join the string so a copy of dayN to dayM doesn't destroy it.
IEx.Helpers.c("/Users/johnb/dev/2" <> "0" <> "1" <> "6adventOfCode/advent_of_code.ex")
alias AdventOfCode, as: AOC
alias Kino.Input
```

## Installation and Data

```elixir
input_example = Kino.Input.textarea("Example Data", monospace: true)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_puzzleInput = Kino.Input.textarea("Puzzle Input", monospace: true)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_source_select =
  Kino.Input.select("Source", [{:example, "example"}, {:puzzle_input, "puzzle input"}])
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
data = fn ->
  (Kino.Input.read(input_source_select) == :example &&
     Kino.Input.read(input_example)) ||
    Kino.Input.read(input_puzzleInput)
end
```

## Solution

```elixir

defmodule Day13 do
  @open "."
  @wall "#"
  @start_x 1
  @start_y 1

  def build_office(favorite_number, grid_size) do
    grid = AOC.as_solid_grid(grid_size, grid_size, "?")
    
    AOC.grid_cells(grid)
    |> Enum.reduce(grid, fn cell_id, acc ->
      x = AOC.grid_x(acc, cell_id)
      y = AOC.grid_y(acc, cell_id)
      n = x*x + 3*x + 2*x*y + y + y*y + favorite_number
      bit_count = Integer.to_string(n, 2)
        |> String.replace("0", "")
        |> String.length()
      Map.put(acc, cell_id, rem(bit_count, 2) == 1 && @wall || @open)
    end)
  end

  def solve1(text) do
    [favorite_number, grid_size, finish_x, finish_y] = text
      |> String.split(",", trim: true)
      |> Enum.map(&String.to_integer/1)

    grid = build_office(favorite_number, grid_size)
    AOC.display_grid(grid)
    
    start = AOC.cell_id(grid, @start_x, @start_x)
    finish = AOC.cell_id(grid, finish_x, finish_y)
    AOC.inspect([start, finish], label: "Finding path")
    updated_node_map = AOC.shortest_path(grid, start, finish)
    %{path: finish_path, cost: _finish_cost} = updated_node_map[finish]
    
    # Subtract the start node from the count
    IO.inspect(Enum.count(finish_path) - 1, label: "\n*** Part 1 solution (example: 11)")

    # Which nodes cost less than 50?
    updated_node_map
    |> Enum.reduce(0, fn {_node_id, %{cost: cost}}, acc ->
      if cost <= 50 do
        acc + 1
      else
        acc
      end
    end)
    |> IO.inspect(label: "\n*** Part 2 solution (example: 20)")
  end

  # def solve2(text) do
  # end
end

# Example data: 10,10,7,4
# Puzzle input: 1352,45,31,39
data.()
|> Day13.solve1()
# Part 1: 90
# Part 2: 135

```
