<!-- vim: syntax=markdown -->

# Day 22

```elixir
# Note: when making the next template, something like this works well:
#   `cat day04.livemd | sed 's/02/04/' > day04.livemd`
# When inspecting lists of numbers, use "charlists: :as_lists"
#
Mix.install([
  # Join the string so a copy of dayN to dayM doesn't destroy it.
  {:kino, "~> 0.1" <> "4.2"}
])

# Join the string so a copy of dayN to dayM doesn't destroy it.
IEx.Helpers.c("/Users/johnb/dev/2" <> "0" <> "2" <> "4adventOfCode/advent_of_code.ex")
alias AdventOfCode, as: AOC
alias Kino.Input
```

## Installation and Data

```elixir
input_example = Kino.Input.textarea("Example Data", monospace: true)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_puzzleInput = Kino.Input.textarea("Puzzle Input", monospace: true)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_source_select =
  Kino.Input.select("Source", [{:example, "example"}, {:puzzle_input, "puzzle input"}])
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
data = fn ->
  (Kino.Input.read(input_source_select) == :example &&
     Kino.Input.read(input_example)) ||
    Kino.Input.read(input_puzzleInput)
end
```

## Solution

```elixir
defmodule Day22 do
  @df_line ~r/\/dev\/grid\/node-x(?<x>\d+)-y(?<y>\d+)\W+(?<size>\d+)T\W+(?<used>\d+)T\W+(?<avail>\d+)T\W+(?<pct>\d+)\%/

  def parse_nodes(text) do
    [_df, _header | lines] = AOC.as_single_lines(text)
    IO.puts("Nodes: #{Enum.count(lines)}")
    IO.inspect(Enum.take(lines, 4))
    
    Enum.map(lines, fn line ->
      Regex.named_captures(@df_line, line)
      |> Enum.map(fn {k, v} -> {String.to_atom(k), String.to_integer(v)} end)
      |> Map.new()
    end)
    
  end
  def solve1(text) do
    node_sizes = parse_nodes(text)
    a_nodes = node_sizes
      |> Enum.reject(fn %{used: used} -> used == 0 end)

    node_sizes
    |> Enum.reduce(0, fn b_node, acc ->
      a_nodes
      |> Enum.reduce(acc, fn a_node, acc2 ->
        if [a_node.x, a_node.y] != [b_node.x, b_node.y] && b_node.avail >= a_node.used do
          acc2 + 1
        else
          acc2
        end
      end)
    end)
  end

  def grid_key(x, y), do: "#{x},#{y}"

  def show_nodes(nodes) do
    max_x = Enum.map(nodes, fn node -> node.x end) |> Enum.max()
    max_y = Enum.map(nodes, fn node -> node.y end) |> Enum.max()
    AOC.inspect([max_x, max_y])

    grid = Enum.reduce(nodes, %{}, fn node, acc ->
      Map.put_new(acc, grid_key(node.x, node.y), node)
    end)
    |> IO.inspect()

    for y <- 0..max_y do
      Enum.map(0..max_x, fn x -> 
        node = Map.get(grid, grid_key(x, y))
        "#{node.avail}/#{node.used}/#{node.size} "
      end)
      |> Enum.join()
      |> IO.puts()
    end
  end

  def solve2(text) do
    nodes = parse_nodes(text)
    show_nodes(nodes)

    nil
  end
end

# Example:

data.()
|> Day22.solve1()
|> IO.inspect(label: "\n*** Part 1 solution (example: )")
# 946

data.()
|> Day22.solve2()
|> IO.inspect(label: "\n*** Part 2 solution (example: )")
# IO.inspect(Time.utc_now())
# 185 is too low (but someone else's answer)

```
